---
title: "Classic API Unhooking"
date: 2022-04-14T20:54:39+0800
TocOpen: true
showToc: true
showbreadcrumbs: true 
tags: ["windows", "PE", "C++"]
categories: ["malware-development"]
---

## Introduction

AV and EDR use API hoooking to monitor API calls of processes. This post will take a brief look on how does a hook look like and the classic solution for malwares to bypass API hooking.

I tested the content of this blog in a windows 10 VM with BitDefender installed.

You can get the sample code [here](https://github.com/KatsuragiCSL/classic-unhooking).

## API hooking

![](/classic-api-unhooking/s1.png)

![](/classic-api-unhooking/s2.png)

On the Windows VM with BitDefender installed, if you load a PE into x64dbg and look for `NtMapViewOfSection`, you will see the first instruction is jmp to something.  
This is NOT how `ZwMapViewOfSection` looks like originally, but an inline hook on this function by BitDefender.

BitDefender set the hook in order to perform its job before the function runs. In order to evade from BitDefender, you need to evade from this hook. The method discussed in this post is known as classic unhooking.

## Creating a view of a fresh copy of ntdll.dll

![](/classic-api-unhooking/1.png)

This is the part responsible for creating a view of the fresh copy of ntdll.dll on disk.

We also need a handle of ntdll.dll which loaded into the current process. It is the one which (some of) its functions are hooked. Let's call it `pollutedNtdll`.

## Rewrite the .text section

![](/classic-api-unhooking/2.png)

These few lines are for getting to the section header (and number of sections for iteration). If you are not familiar with PE structure, you could take a look at [PE101](https://github.com/corkami/pics/tree/master/binary/pe101) which has nice pictures. You may also want to refer to MSDN pages like [this](https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_nt_headers64).

We also defined a `DWORD` variable `oldprotect` for saving the [old access protection value](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect).

![](/classic-api-unhooking/3.png)

You can get the number of sections in a PE file in the `IMAGE_FILE_HEADER` structure. We iterate through the sections and find the `.text` section.  
If we get it, we make the `.text` section of pollutedNtdll writable, by `VirtualProtect`.

![](/classic-api-unhooking/4.png)

Now we can copy the `.text` section from the fresh copy of `ntdll.dll` to the one polluted.

![](/classic-api-unhooking/5.png)

Finally make sure we recover the access protection.

## Ntdll.dll unhooked

Now we set a breakpoint on an instruction after the unhooking (in this case it is where "done!" is printed).  
Run it and the breakpoint is hit:

![](/classic-api-unhooking/s3.png)

Back to the address of `ZwMapViewOfSection`, you can see the hook is gone.

![](/classic-api-unhooking/s4.png)

## Afterword

First of all, as a simple sample, I did not put any effort in obfuscating my function calls/ strings etc. So the code is definitely far from ready-to-go.  
There will probably be posts about basic obfuscation in the future.

And, is it a perfect solution for API unhooking? Of course not, as it's called **Classic** unhooking :)  
In fact, there is a part looks suspicious when we unhooking like this, as in the EDR's point of view:

> Why the heck is this process reading `ntdll.dll` from disk???[^1]

Yes, normal process should not read `ntdll.dll` "manually", as it should be automatically loaded. There will be posts about more advanced technique for unhooking in the future.

[^1]: https://www.cyberbit.com/blog/endpoint-security/malware-mitigation-when-direct-system-calls-are-used/
