<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on KatsuragiCSL</title><link>https://katsuragicsl.github.io/posts/</link><description>Recent content in Posts on KatsuragiCSL</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0&lt;/a></copyright><lastBuildDate>Thu, 14 Apr 2022 20:54:39 +0800</lastBuildDate><atom:link href="https://katsuragicsl.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Classic API Unhooking</title><link>https://katsuragicsl.github.io/posts/2022/04/classic-api-unhooking/</link><pubDate>Thu, 14 Apr 2022 20:54:39 +0800</pubDate><guid>https://katsuragicsl.github.io/posts/2022/04/classic-api-unhooking/</guid><description>Introduction AV and EDR use API hoooking to monitor API calls of processes. This post will take a brief look on how does a hook look like and the classic solution for malwares to bypass API hooking.
I tested the content of this blog in a windows 10 VM with BitDefender installed.
You can get the sample code here.
API hooking On the Windows VM with BitDefender installed, if you load a PE into x64dbg and look for NtMapViewOfSection, you will see the first instruction is jmp to something.</description><content type="html"><![CDATA[<h3 id="introduction">Introduction</h3>
<p>AV and EDR use API hoooking to monitor API calls of processes. This post will take a brief look on how does a hook look like and the classic solution for malwares to bypass API hooking.</p>
<p>I tested the content of this blog in a windows 10 VM with BitDefender installed.</p>
<p>You can get the sample code <a href="https://github.com/KatsuragiCSL/classic-unhooking">here</a>.</p>
<h3 id="api-hooking">API hooking</h3>
<p><img src="/classic-api-unhooking/s1.png" alt=""></p>
<p><img src="/classic-api-unhooking/s2.png" alt=""></p>
<p>On the Windows VM with BitDefender installed, if you load a PE into x64dbg and look for <code>NtMapViewOfSection</code>, you will see the first instruction is jmp to something.<br>
This is NOT how <code>ZwMapViewOfSection</code> looks like originally, but an inline hook on this function by BitDefender.</p>
<p>BitDefender set the hook in order to perform its job before the function runs. In order to evade from BitDefender, you need to evade from this hook. The method discussed in this post is known as classic unhooking.</p>
<h3 id="creating-a-view-of-a-fresh-copy-of-ntdlldll">Creating a view of a fresh copy of ntdll.dll</h3>
<p><img src="/classic-api-unhooking/1.png" alt=""></p>
<p>This is the part responsible for creating a view of the fresh copy of ntdll.dll on disk.</p>
<p>We also need a handle of ntdll.dll which loaded into the current process. It is the one which (some of) its functions are hooked. Let&rsquo;s call it <code>pollutedNtdll</code>.</p>
<h3 id="rewrite-the-text-section">Rewrite the .text section</h3>
<p><img src="/classic-api-unhooking/2.png" alt=""></p>
<p>These few lines are for getting to the section header (and number of sections for iteration). If you are not familiar with PE structure, you could take a look at <a href="https://github.com/corkami/pics/tree/master/binary/pe101">PE101</a> which has nice pictures. You may also want to refer to MSDN pages like <a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_nt_headers64">this</a>.</p>
<p>We also defined a <code>DWORD</code> variable <code>oldprotect</code> for saving the <a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect">old access protection value</a>.</p>
<p><img src="/classic-api-unhooking/3.png" alt=""></p>
<p>You can get the number of sections in a PE file in the <code>IMAGE_FILE_HEADER</code> structure. We iterate through the sections and find the <code>.text</code> section.<br>
If we get it, we make the <code>.text</code> section of pollutedNtdll writable, by <code>VirtualProtect</code>.</p>
<p><img src="/classic-api-unhooking/4.png" alt=""></p>
<p>Now we can copy the <code>.text</code> section from the fresh copy of <code>ntdll.dll</code> to the one polluted.</p>
<p><img src="/classic-api-unhooking/5.png" alt=""></p>
<p>Finally make sure we recover the access protection.</p>
<h3 id="ntdlldll-unhooked">Ntdll.dll unhooked</h3>
<p>Now we set a breakpoint on an instruction after the unhooking (in this case it is where &ldquo;done!&rdquo; is printed).<br>
Run it and the breakpoint is hit:</p>
<p><img src="/classic-api-unhooking/s3.png" alt=""></p>
<p>Back to the address of <code>ZwMapViewOfSection</code>, you can see the hook is gone.</p>
<p><img src="/classic-api-unhooking/s4.png" alt=""></p>
<h3 id="afterword">Afterword</h3>
<p>First of all, as a simple sample, I did not put any effort in obfuscating my function calls/ strings etc. So the code is definitely far from ready-to-go.<br>
There will probably be posts about basic obfuscation in the future.</p>
<p>And, is it a perfect solution for API unhooking? Of course not, as it&rsquo;s called <strong>Classic</strong> unhooking :)<br>
In fact, there is a part looks suspicious when we unhooking like this, as in the EDR&rsquo;s point of view:</p>
<blockquote>
<p>Why the heck is this process reading <code>ntdll.dll</code> from disk???<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></p>
</blockquote>
<p>Yes, normal process should not read <code>ntdll.dll</code> &ldquo;manually&rdquo;, as it should be automatically loaded. There will be posts about more advanced technique for unhooking in the future.</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p><a href="https://www.cyberbit.com/blog/endpoint-security/malware-mitigation-when-direct-system-calls-are-used/">https://www.cyberbit.com/blog/endpoint-security/malware-mitigation-when-direct-system-calls-are-used/</a> <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content></item></channel></rss>